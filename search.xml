<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github+hexo搭建个人主页</title>
    <url>/2019/06/10/github-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="想搭的朋友可以看看"><a href="#想搭的朋友可以看看" class="headerlink" title="想搭的朋友可以看看"></a>想搭的朋友可以看看</h1><a id="more"></a>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul>
<li>nodejs</li>
<li>git</li>
<li>github</li>
<li>域名</li>
<li>hexo</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/av24897960/" target="_blank" rel="noopener">搭建视频</a>&nbsp;&nbsp;&nbsp;<a href="https://www.bilibili.com/video/av17653359/" target="_blank" rel="noopener">主题优化视频</a>&nbsp;&nbsp;&nbsp;<a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&utm_medium=social" target="_blank" rel="noopener">知乎</a>&nbsp;&nbsp;&nbsp;<a href="https://heshang.ink/2018/07/21/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%EF%BC%89/" target="_blank" rel="noopener">某博主</a><br><a href="tholman.com/github-corners">github图标</a>&nbsp;&nbsp;&nbsp;<a href="https://fontawesome.com" target="_blank" rel="noopener">icon</a></p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ul>
<li>有些功能要下载依赖</li>
<li>还有些莫名其妙的坑，新版本和教程都不太一样</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客如何迁移</title>
    <url>/2020/04/04/hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="终于想起来要给博客换个窝"><a href="#终于想起来要给博客换个窝" class="headerlink" title="终于想起来要给博客换个窝"></a>终于想起来要给博客换个窝</h1><a id="more"></a>
<h2 id="1-首先将原来的仓库复制-仅需复制以下几个文件"><a href="#1-首先将原来的仓库复制-仅需复制以下几个文件" class="headerlink" title="1.首先将原来的仓库复制(仅需复制以下几个文件)"></a>1.首先将原来的仓库复制(仅需复制以下几个文件)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure>

<h2 id="2-在新电脑上安装hexo环境"><a href="#2-在新电脑上安装hexo环境" class="headerlink" title="2.在新电脑上安装hexo环境"></a>2.在新电脑上安装hexo环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="下载node包"><a href="#下载node包" class="headerlink" title="下载node包"></a>下载node包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下安装ngrok实现内网穿透</title>
    <url>/2020/04/10/Mac%E4%B8%8B%E5%AE%89%E8%A3%85ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><a id="more"></a>
<ul>
<li><ol>
<li>从官网下载ngrko(<a href="http://www.ngrok.com/" target="_blank" rel="noopener">点击下载</a>)</li>
</ol>
</li>
<li><ol start="2">
<li>解压并拖到Application文件夹下</li>
</ol>
</li>
<li><ol start="3">
<li>建立软连接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">ln -s /Applications/ngrok ngrok</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="4">
<li>将authtoken加到ngrok.yml中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngrok authtoken yourself-token</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="5">
<li>启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngrok http 8080</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>web应用测试</title>
    <url>/2019/07/10/web%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="感觉公司都不用这些o-￣▽￣-o"><a href="#感觉公司都不用这些o-￣▽￣-o" class="headerlink" title="感觉公司都不用这些o(￣▽￣)o"></a>感觉公司都不用这些o(<em>￣▽￣</em>)o</h1><a id="more"></a>
<h2 id="1-工具的安装"><a href="#1-工具的安装" class="headerlink" title="1.工具的安装"></a>1.工具的安装</h2><ul>
<li>Jmeter安装，只需要在<a href="http://jmeter.apache.org/" target="_blank" rel="noopener">官网下载</a>,直接安装即可，使用时直接打开安装bin目录下的jmeter.bat</li>
<li>Jmeter使用，可以设置行为和监听，以及设置线程等</li>
<li>badboy安装，为了更简便的使用Jmeter录制脚本安装badboy，<a href="http://www.51testing.com/html/79/n-854279.html" target="_blank" rel="noopener">下载地址</a>,傻瓜式安装即可</li>
<li>selenium安装，selenium是python3自带的(python2需另下)，若是用selenium测试web，还需要下各个浏览器的driver，也无法录制需自己写脚本，为了更方便的录制下载了<a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">selenium IDL</a>,这次测试全在chrome中，所以下载的是selenium IDE for chrome(之前只支持FireFox),直接用chrome打开，chrome商店会自动自动加载这个插件，会显示在右上角</li>
</ul>
<hr>
<h2 id="2-selenium-amp-Jmeter脚本的录制"><a href="#2-selenium-amp-Jmeter脚本的录制" class="headerlink" title="2.selenium&amp;Jmeter脚本的录制"></a>2.selenium&amp;Jmeter脚本的录制</h2><p>####1.selenium</p>
<ul>
<li>1.1 打开selenium IDE,输入一个初始url,IDE会以打开这个初始url为标志进行录制<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/29f5f64860795e47935e/1.PNG" alt="图2.1"></li>
<li>1.2 以google.com为例，这次录制脚本就是打开谷歌首页，搜索一个词hello,录制录制结束以后直接点击右上角的停止，然后保存即可，会保存为一个<a href="/selenium-test.side">.side文件</a></li>
</ul>
<p>####2.Jmeter&amp;badboy</p>
<ul>
<li>2.1 用badboy进行辅助录制，打开badboy,新建一个test,进入google.com,点击play按钮开始录制，同样搜索一个词hello,录制结束以后点击红色圆圈，然后可以点击菜单栏的view -&gt; report看录制的一些数据，若要导出Jmeter脚本，则点击file -&gt; export to Jmeter,生成以一个<a href="/badboy-test.jmx">jmx文件</a><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/b463790efe1e7f4c5172/2.PNG" alt="图2.2"><br>####3.两种脚本差别分析</li>
<li>3.2首先看badboy录制的脚本<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/4608fab402b850e7df07/2.1.PNG" alt="图2.3"><br>文件中首先有对线程组（ThreadGroup）的定义，说明利用jmx脚本可以进行规模化的测试。文件主体内容由一系列采样器（HTTPSampler）组成，每条HTTPSampler标签内包含了一系列属性，对应一条http请求。</li>
<li>3.3再看selenium录制的脚本<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/d66cf7e1d55d3af5dde6/2.2.PNG" alt="图2.4"><br>由文件内容可知，一个测试场景的测试过程由一条条命令（command）构成，每条命令包括命令类型、命令目标</li>
<li>3.4差异：最明显的就是长度,badboy录制的脚本显然长度更长。另外selenium更注重应用测试，jmx脚本注重性能压力测试</li>
</ul>
<hr>
<h2 id="3-web应用性能测试-基于三个场景"><a href="#3-web应用性能测试-基于三个场景" class="headerlink" title="3.web应用性能测试(基于三个场景)"></a>3.web应用性能测试(基于三个场景)</h2><ul>
<li>3.1 这里是两个脚本，<a href="http://lc-rvl5rora.cn-n1.lcfile.com/11f43dd926362a9aba84/why.jmx" target="_blank" rel="noopener">test1</a>,<a href="http://lc-rvl5rora.cn-n1.lcfile.com/69a59b05fefeab15fed7/qqmail.jmx" target="_blank" rel="noopener">test2</a>,都进行了三个场景的测试</li>
<li>3.2 test1脚本完成了进入redmine-&gt;登录redmine-&gt;点击我的工作台并查看maven项目，test2脚本完成了进去qq邮箱界面-&gt;登录qq邮箱-&gt;点击收件箱并查看一封邮件</li>
<li>3.3 脚本参数化：在test1测试中对脚本进行了参数化，设置了登陆的账户名和密码，从文件读取<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/cbb8175d5c06e3fdc0ad/4.PNG" alt="图3.1"></li>
<li>3.4 测试场景配置：<br>(1)设置线程、访问时间、循环数,只需要点击thread group进行设置即可,如图设置了100个线程在10秒内执行并进行两个循环<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/c2b79c3c472205bcb6f3/3.PNG" alt="图3.2"><br>(2)设置查看结果树。查看结果树可以很清晰的看到该网页是否访问成功(绿色代表成功，红色则不成功)add-&gt;listener-&gt;view results tree<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/ca8cfed1b0aefe7c9447/5.PNG" alt="图3.3"><br>(3)设置断言。这个功能和查看结果树有些相似，可以根据界面上的一些元素进行匹配来判断一个界面是否访问成功，首先添加断言add-&gt;assertions-&gt;response assertions<br>再添加断言结果 add-&gt;listener-&gt;assertion results<br>若是未能成功怕匹配则断言中会出现fail<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/6d35f2c01a58b4ad9d67/6.PNG" alt="图3.4"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/de0c509865bb61cbf973/7.PNG" alt="图3.5"><br>(4)添加一些用以分析网页性能的report以及graph(summary report,aggregate report,response time graph等)<br>(5)测试执行可以直接run或是单步执行，在执行过程中就可以看到结果<br>(6)结果分析(以test2文件为例)，首先在总体结果报告中可以看到我的出错率为0，平均响应时间为83,最大响应时间以及最小响应时间分别为33/417,传输速度达到589.93kb,从数据上来看网页性能较好<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/74fe664de921f968fb08/8.PNG" alt="图3.6"><br>那么在查看结果树中因为错误是0所以是全是绿的<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/d581f52ca6745960cf0d/9.PNG" alt="图3.7"><br>结果图将总体报告中的一些数据用图反映出来<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/618ee82c9614dcbecd84/10.PNG" alt="图3.8"><br>再看响应时间图，一直较为平稳，也就是说即使是密集访问的时间也能保持较快的响应时间，这也能看出网站的性能较好<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/77db44a5d77e46324fa7/11.PNG" alt="图3.9"></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title>idea下搭建springboot聚合工程</title>
    <url>/2020/04/10/idea%E4%B8%8B%E6%90%AD%E5%BB%BAspringboot%E8%81%9A%E5%90%88%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="什么是聚合工程"><a href="#什么是聚合工程" class="headerlink" title="什么是聚合工程"></a>什么是聚合工程</h1><a id="more"></a>
<ul>
<li>聚合工程（maven项目，parent project）是将许多子工程（common，pojo，dao，service，controller）聚合在一起，并通过相互依赖，形成父子关系，当我们要编写某一部分时候，比如建立实体类时，我们就在pojo类中编写即可，无需管其他子工程。</li>
<li>common子工程一般我们将基础的依赖导入，同时一般的工具类我们都会存放在这一层，便于更上层的工程要使用；pojo层就是我们存放实体类的地方，也可以称为entity层；dao层如果使用的是mybatis就存放mapper，使用spring data jpa就存放repository；service层就是存放service类；web层就是我们的controller层，我们编写的api接口都存放在该层。</li>
</ul>
<h1 id="在idea里创建聚合工程"><a href="#在idea里创建聚合工程" class="headerlink" title="在idea里创建聚合工程"></a>在idea里创建聚合工程</h1><ol>
<li>首先创建副工程，这里选择Maven Pom即可，只需要一个pom文件<br><img src="http://lc-RVL5Rora.cn-n1.lcfile.com/b4f853325ed68d4cd757/a.png" alt="图1"><br><img src="http://lc-RVL5Rora.cn-n1.lcfile.com/b1317d7dc746acdd5887/%20b.png" alt="图2"></li>
<li>接下来创建子工程，比如pojo,service,common,mapper等</li>
</ol>
<ul>
<li>file -&gt; new -&gt; module,接着同样的步骤选择Maven Project即可</li>
<li>要注意的是创建完之后需要在每个子工程里添加依赖，比如pojo依赖common,则在pojo的pom文件中添加对common的依赖<br><img src="http://lc-RVL5Rora.cn-n1.lcfile.com/d167ff101e17ec0c104f/c.png" alt="图3"></li>
</ul>
<ol start="3">
<li><a href="https://github.com/wsilencelight/wechat-springboot" target="_blank" rel="noopener">demo</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个自己的日期选择器</title>
    <url>/2019/06/13/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><a id="more"></a>
<h2 id="首先谈谈要做成的效果"><a href="#首先谈谈要做成的效果" class="headerlink" title="首先谈谈要做成的效果"></a>首先谈谈要做成的效果</h2><ul>
<li>日期选择器一般应用在什么地方呢？<ul>
<li>当我们填信息需要填日期的时候，用户希望能够更直观的选择出日期，而作为开发者则希望</li>
<li>日期的格式是一定的</li>
</ul>
</li>
<li>那么大概的样式就出来了，一个输入框，当鼠标点击的时候弹出日期，选择完日期以后则将选择的日期显示在输入框中<br><img src="http://lc-RVL5Rora.cn-n1.lcfile.com/248bbcb2033c242a1874/datepicker.JPG" alt="效果图"></li>
</ul>
<h2 id="样式的实现"><a href="#样式的实现" class="headerlink" title="样式的实现"></a>样式的实现</h2><ul>
<li>看上图可以发现这主要包括两部分内容<ul>
<li>1.input框，这个input框是一直存在的，没什么特别的样式，修改下border-radius和修改默认蓝色outline，用Box-shadow来定义自己的点击效果，使其更加适应整体色调</li>
<li>2.一个div，里面包括两部分内容，一个可以左右切换月份的年月显示模块，一个table显示日期，可以先用静态数据填上</li>
</ul>
</li>
<li>具体的样式就不细说了主要来看js部分</li>
</ul>
<h2 id="功能的实现"><a href="#功能的实现" class="headerlink" title="功能的实现"></a>功能的实现</h2><ul>
<li>1.可以打开windows的日历看看，会发现不管一个月有几天，一张table都会用6 * 7的行列数来表示，所以我们的日历行列也定死为6 * 7</li>
<li>2.首先，我们需要用到js中的Date()对象，下面是几个会用到的API<pre><code>1.Date(year, month, date),该对象接收三个参数，分别是年，月，日(特别要注意的是月份是0-11,而date为0代表上个月最后一天)，默认返回当前时间的Date对象
2.Date.getFullYear()获取年份
3.Date.getDate()获取日期
4.Date.getMonth()获取月份
5.Date.getDay()获取星期，我们都知道欧美周日算一周的第一天，所以是0-6，0表示周日，这里需要注意下</code></pre></li>
<li>3.知道怎么获取数据之后接下来就是关键部分，怎么让这42个日期在一张table中正确显示呢？<pre><code>1.我需要知道本月第一天的完整数据，Date(year, month-1, 1),这里的month是我们认为的month,因为其接收的是
0-11,所以需要减去1
2.我们需要知道上月最后一天的完整数据，Date(year, month-1, 0),之前也提到0表示上个月最后一天，这是因为在接收到0这个参数以后相当于回退一天
3.我们需要知道本月最后一天的完整数据，Date(year, month, 0),可以利用下个月的month回退来货得这个月的最后一天</code></pre></li>
<li><ol start="4">
<li>这个坑留在这一个月没更新了，这周末要是不加班一定更新</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>promise与callback对比</title>
    <url>/2020/04/04/promise%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="promise-vs-callback"><a href="#promise-vs-callback" class="headerlink" title="promise vs callback"></a>promise vs callback</h1><a id="more"></a>
<h2 id="以一个简单的http请求类为例"><a href="#以一个简单的http请求类为例" class="headerlink" title="以一个简单的http请求类为例"></a>以一个简单的http请求类为例</h2><ul>
<li>为了更好的显示功能用了两个文件http.js和classic.js</li>
<li>异步操作显然剥夺了函数的return能力，通常用回调函数来获取返回的结果，回调函数易于理解，但容易造成callback hell让代码看起来混乱难以理解</li>
<li>promise(包括promise的语法糖 async await)能很好的解决这个问题。虽然本质上没有区别但是从写法上看promise的这种链式写法显然比一层又一层的回调显得代码简洁和易于理解(有关promise的详解请看下篇)</li>
</ul>
<h3 id="callback实现"><a href="#callback实现" class="headerlink" title="callback实现"></a>callback实现</h3><ul>
<li><p>1.http.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HTTP &#123;</span><br><span class="line">  request (&#123;url, data = &#123;&#125;, method = &apos;GET&apos;,success&#125;) &#123;</span><br><span class="line">      wx.request(&#123;</span><br><span class="line">        url: config.api_base_url + url,</span><br><span class="line">        method: method,</span><br><span class="line">        data: data,</span><br><span class="line">        header: &#123;</span><br><span class="line">          &apos;content-type&apos;: &apos;application/json&apos;,</span><br><span class="line">          &apos;appkey&apos;: config.appkey</span><br><span class="line">        &#125;,</span><br><span class="line">        success: (res) =&gt; &#123;</span><br><span class="line">        let code = String(res.statusCode)</span><br><span class="line">        if (code.startsWith(&apos;2&apos;)) &#123;</span><br><span class="line">            // 回调函数</span><br><span class="line">            success(res)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">            // title: res.data ? res.data.msg : &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">            title: &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">            icon: &apos;none&apos;,</span><br><span class="line">            duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: (err) =&gt; &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title: &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.classic.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassicModel extends HTTP &#123;</span><br><span class="line">  getLatest (callback) &#123;</span><br><span class="line">    this.request(&#123;</span><br><span class="line">      url: &apos;classic/latest&apos;,</span><br><span class="line">      method: &apos;GET&apos;,</span><br><span class="line">      success: (res) =&gt; &#123;</span><br><span class="line">        callback(res.data)</span><br><span class="line">        this._setLatestIndex(res.data.index)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _setLatestIndex(index) &#123;</span><br><span class="line">    wx.setStorageSync(&apos;latestIndex&apos;, index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="promise实现"><a href="#promise实现" class="headerlink" title="promise实现"></a>promise实现</h3><ul>
<li><p>1.http.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HTTP &#123;</span><br><span class="line">  request (&#123;url, data = &#123;&#125;, method = &apos;GET&apos;&#125;) &#123;</span><br><span class="line">    const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      wx.request(&#123;</span><br><span class="line">        url: config.api_base_url + url,</span><br><span class="line">        method: method,</span><br><span class="line">        data: data,</span><br><span class="line">        header: &#123;</span><br><span class="line">          &apos;content-type&apos;: &apos;application/json&apos;,</span><br><span class="line">          &apos;appkey&apos;: config.appkey</span><br><span class="line">        &#125;,</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          let code = String(res.statusCode)</span><br><span class="line">          if (code.startsWith(&apos;2&apos;)) &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              // title: res.data ? res.data.msg : &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">              title: &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">              icon: &apos;none&apos;,</span><br><span class="line">              duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: (err) =&gt; &#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title: &apos;请求异常，请稍后再试&apos;,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.classic.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassicModel extends HTTP &#123;</span><br><span class="line">  getLatest () &#123;</span><br><span class="line">    const params = &#123;</span><br><span class="line">      url: &apos;classic/latest&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.request(params).then(res =&gt; &#123;</span><br><span class="line">      this._setLatestIndex(res.data.index)</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(res.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _setLatestIndex(index) &#123;</span><br><span class="line">    wx.setStorageSync(&apos;latestIndex&apos;, index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>实用网站大汇总</title>
    <url>/2019/06/11/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E5%A4%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="为了防止自己找不到，把网址留在这"><a href="#为了防止自己找不到，把网址留在这" class="headerlink" title="为了防止自己找不到，把网址留在这"></a>为了防止自己找不到，把网址留在这</h1><a id="more"></a>

<h2 id="分类是不可能分的"><a href="#分类是不可能分的" class="headerlink" title="分类是不可能分的"></a>分类是不可能分的</h2><ul>
<li><a href="https://fontawesome.com" target="_blank" rel="noopener">font-awesome图标库</a> 一个font-awesome的图标库，当然使用前得先去下js文件</li>
<li><a href="http://www.divcss5.com/peise/" target="_blank" rel="noopener">css配色表</a> 搞不懂颜色的时候看看</li>
<li><a href="https://www.iconfont.cn" target="_blank" rel="noopener">iconfont</a> 阿里巴巴矢量图标库，看看各公司的ui设计(用起来爽的一批)</li>
<li><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 国内的github,访问比较快吧，但是广告有点小多</li>
<li><a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a> 服务端托管平台，贼好用</li>
<li><a href="https://valine.js.org" target="_blank" rel="noopener">valine</a> 基于leancloud的一款快速、简洁且高效的无后端评论系统</li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a> next主题配置</li>
<li><a href="https://echarts.baidu.com/" target="_blank" rel="noopener">echarts</a> 目前较流行的图标框架</li>
<li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a> 同样是服务端托管平台</li>
<li>未完待续</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个自己的集成化测试环境</title>
    <url>/2019/06/30/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9B%86%E6%88%90%E5%8C%96%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="持续集成与测试"><a href="#持续集成与测试" class="headerlink" title="持续集成与测试"></a>持续集成与测试</h1><a id="more"></a>
<h2 id="1-Redmine"><a href="#1-Redmine" class="headerlink" title="1.Redmine"></a>1.Redmine</h2><ul>
<li><p>1.1直接官网下的redmine安装过程过于复杂，所以我选择了Bitnami上的安装包，省去繁琐的过程(<a href="https://bitnami.com/stack/redmine" target="_blank" rel="noopener">下载地址</a>)</p>
</li>
<li><p>1.2安装完成输入用户名和密码，注意此时的用户名密码是管理员权限，需要记牢。</p>
</li>
<li><p>1.3之后用外网访问的时候出了点问题，不论怎么改设置都无法访问，查询后发现是阿里云的ECS云服务器的安全策略默认该服务器是专有的，外网访问需要修改安全组策略(一处修改为80/80,一处修改为0.0.0.0/0,具体可自行查询)</p>
</li>
</ul>
<h2 id="2-Git-amp-GitStack"><a href="#2-Git-amp-GitStack" class="headerlink" title="2.Git&amp;GitStack"></a>2.Git&amp;GitStack</h2><ul>
<li>2.1 可以单独下Git也可以用GitStack里带的git(单独下git比较方便)</li>
<li>2.2 Git下载地址(<a href="https://git-scm.com/downloads),GitStack下载地址(https://gitstack.com/)" target="_blank" rel="noopener">https://git-scm.com/downloads),GitStack下载地址(https://gitstack.com/)</a></li>
<li>2.3 Git下载完成后需要配置环境变量(也可不配，配的话在path里加上git的路径),GitStack是傻瓜式安装(内自带apache),按照安装过程自动安装即可，默认端口是80，下载完成后直接输入localhost/gitstack即可打开，(初始登录密码为admin,admin,未修改),登陆成功后界面如下<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/43690322fb1115cae310/1.png" alt="图2.1"></li>
<li>2.4 在users&amp;Groups里可以新建用户，在这里新建名为nuaa的用户,用户名密码作为之后clone和push的凭证<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/63e7325798209c187d4c/2.png" alt="图2.2"><br>创建完之后可以看到users里已经有了nuaa用户<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/8c3a651c8d4fc1ce77c8/3.png" alt="图2.3"></li>
<li>2.5 同理可以在repositories里完成项目的创建，以下是两个创建完的项目，command to clone里是之后clone的地址<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/85070a7a8b00c082f0d6/4.png" alt="图2.4"></li>
</ul>
<hr>
<h2 id="3-Jenkins"><a href="#3-Jenkins" class="headerlink" title="3.Jenkins"></a>3.Jenkins</h2><ul>
<li><p>3.1 首先去jenkins官网下载jenkins(<a href="https://jenkins.io/),下载完后自动安装，安装完成以后就会自动进入初始界面，用jenkins/secrets里的初始password登录，就可以登录jenkins" target="_blank" rel="noopener">https://jenkins.io/),下载完后自动安装，安装完成以后就会自动进入初始界面，用jenkins/secrets里的初始password登录，就可以登录jenkins</a><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/d9150eaef855a81de01d/5.png" alt="图3.1"></p>
</li>
<li><p>3.1 接下来是配置，可参考<a href="https://blog.csdn.net/qq_39720249/article/details/81264634#%E5%9B%9B%E3%80%81Jenkins%E5%88%9D%E5%A7%8B%E7%99%BB%E5%BD%95%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%B4%A6%E6%88%B7%C2%A0" target="_blank" rel="noopener">博客</a><br>首先对全局安全进行配置，勾选允许用户注册，并打开安全矩阵，安全矩阵可以规定每个用户的行为<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/5c251a8b4b4de0bf0d7b/6.png" alt="图3.2"></p>
</li>
<li><p>3.2 接着需要在jekins中配置全局工具，暂时配置jdk,maven,git，配置具体不做过多叙述，配置完成后如下<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/6b6bb2dbe39aaade84fc/7.png" alt="图3.2"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/84f070f1bc853b07b916/8.png" alt="图3.3"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/feafcb148dfb6cd21bc5/9.png" alt="图3.4"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/e868980a6db6894bb439/10.png" alt="图3.5"></p>
</li>
<li><p>3.3 安装必要的插件，插件较多，除了博客中的外还需要</p>
<blockquote>
<p>Maven Info Plugin<br>Maven Integration plugin<br>Maven Release Plug-in</p>
</blockquote>
</li>
<li><p>3.4 安装插件完成之后重启jenkins，接着我们就可以new一个maven project,这里以test为例<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/0c964a7ad85a5bcfd601/11.png" alt="图3.6"><br>在Source Code Management选择git，并把之前gitstack创建的clone地址写入<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/acc3d9364c55eda6074a/14.png" alt="图3.7"><br>接着可以勾选轮询SCM,项目就会按时重复运行<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/0e8c8e50e986929699e9/12.png" alt="图3.8"><br>接着点击save，发现项目创建成功<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/9b995be1705664aba0b6/13.png" alt="图3.9"></p>
</li>
<li><p>3.5 创建成功之后点击立即构建，若是不成功显示红色，成功则会显示蓝色<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/64b1008401a3f4b3148c/15.png" alt="图3.10"><br>因为该clone地址的库是我之前写好的一个maven项目，所以已经可以进行测试</p>
<ul>
<li>3.6 在系统管理的管理用户里新建一个用户nuaa<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/7e80f5f376a9a43243df/16.png" alt="图3.11"></li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-项目开发测试完整流程-若有人接手项目可看此流程"><a href="#4-项目开发测试完整流程-若有人接手项目可看此流程" class="headerlink" title="4.项目开发测试完整流程(若有人接手项目可看此流程)"></a>4.项目开发测试完整流程(若有人接手项目可看此流程)</h2><ul>
<li>4.1 以nuaa账户为例,首先在登录gitstack，在上面新建一个项目maventest2(不要忘记往项目中添加可访问用户),接着可在本机clone下来，输入如下指令，并输入之前创建的用户名和密码<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/ffb4d1950905e8d17211/17.PNG" alt="图4.1"></li>
<li>4.2 将之前开发者实验2的项目放入，再push回去git库<blockquote>
<p>git add .<br>git commit -m “add files”<br>git push</p>
</blockquote>
</li>
</ul>
<p>接着输入用户名密码就会显示update成功，这时候查看gitstack就会看到提交记录<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/8c9f349bced2ce6ce93c/19.PNG" alt="图4.2"></p>
<ul>
<li>4.3 在jenkins里对之前新建的项目test进行重新配置，添加访问git的账号为nuaa<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/1d21f7202edb7fb171c4/20.png" alt="图4.3"></li>
<li>4.4 重新构建项目,发现项目构建成功，可以看下测试集正好是之前junit生成的两个测试类(完成冒烟测试)<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/9e2551a4aa6db27510c8/21.png" alt="图4.4"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/95e9a8a4b9c076d2a636/22.png" alt="图4.5"></li>
<li>4.5 若是出现测试错误会显示黄色，我重新修改了代码，注入错误以后上传到git，依然是maventest2.git，这时候新建一个maven2项目，配置同上，选择立即构建，可以看到出现了测试错误<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/4135b8fbe3fecdd28b58/23.PNG" alt="图4.6"></li>
<li>4.6 点开test-result可以看到错误出现在哪<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/54ffd9ac97eeb293269f/24.PNG" alt="图4.7"></li>
<li>4.7 为了更好的进行缺陷管理和跟踪，我将redmine集成到jenkins中(这里两个集成就学到了皮毛),首先安装如下插件<blockquote>
<p>Redmine Plugin<br>Redmine Metrics Report</p>
</blockquote>
</li>
<li>4.8 接着在系统管理里配置redmine路径及版本，版本可在redmine的管理-&gt;配置-&gt;版本库里查看，还需要在API中勾选如下配置<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/669f0deb24dac098975f/25.PNG" alt="图4.8"></li>
<li>4.9 最后在创建项目的时候勾选Assign Redmine project即可将jenkins项目与redmine集成,这里面项目名选择redmine里已创建的项目名<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/c3640c1e95d989ea25ec/26.PNG" alt="图4.9"></li>
<li>4.10 回到之前的测试错误，发现错误以后在redmine里进行问题登记并分配给人员去处理,先点击左侧redmine，然后用redmine账号密码登陆，进去发布问题并让人解决(先在项目里添加此项目人员，否则无法指派给他人)<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/c2fed4b3529fb9a1a871/27.PNG" alt="图4.10"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/947cd3d855647f10748a/28.PNG" alt="图4.11"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/54eb36e75aff57319e2c/29.PNG" alt="图4.12"></li>
<li>4.11 项目人员接到指派任务以后，clone代码测试修复以后再传到git库，若是正确SCM轮询会自动跑通，接着就可以到redmine上把错误登记解决并登记工时，流程结束<br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/ec6750dbb37b0a5c5e10/30.PNG" alt="图4.13"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/2ea2167e396d399c1efa/31.PNG" alt="图4.14"><br><img src="http://lc-rvl5rora.cn-n1.lcfile.com/9fb7c5db5ed218daabd4/32.PNG" alt="图4.15"></li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序之插槽和外部样式</title>
    <url>/2020/04/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%8F%92%E6%A7%BD%E5%92%8C%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>😷</p>
<a id="more"></a>
<h1 id="在小程序中使用插槽"><a href="#在小程序中使用插槽" class="headerlink" title="在小程序中使用插槽"></a>在小程序中使用插槽</h1><ul>
<li><p>小程序中使用插槽和vue等大同小异，不过需要在component里声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  multipleSlots: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不管是几个插槽都需要声明否则插槽不起作用</p>
</li>
<li><p>组件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;num&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;w-tag&gt;</span><br><span class="line">    &lt;text slot=&quot;num&quot;&gt;slot&lt;/text&gt;</span><br><span class="line">&lt;/w-tag&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="小程序中的外部样式"><a href="#小程序中的外部样式" class="headerlink" title="小程序中的外部样式"></a>小程序中的外部样式</h1><ul>
<li><p>在封装组件的时候我们希望能够让使用组件的人能够自行修改样式，通过像传值的方式，在小程序中可以通过在component里声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">externalClasses: [&apos;ex-tag1&apos;,&apos;ex-tag2&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;container ex-tag1&quot;&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;slot name=&quot;num&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面中,在页面中定义样式覆盖即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;w-tag ex-tag1=&quot;ex-tag1&quot; /&gt;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
